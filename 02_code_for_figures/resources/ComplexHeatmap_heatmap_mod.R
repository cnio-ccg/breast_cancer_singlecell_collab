check_gp = function(gp) {
  if(!"lineheight" %in% names(gp)) {
    gp$lineheight = 0.9
  }
  if(!inherits(gp, "gpar")) {
    stop_wrap("Graphic parameters should be specified by `gpar()`.")
  }
  return(gp)
}

height = function(x, ..., value) {
  
  if(x@which == "row") {
    x@height = value
    for(i in seq_along(x@anno_list)) {
      height(x@anno_list[[i]]) = height
    }
  } else {
    x = re_size(x, height = value)
  }
  x
}

get_text_just = function(rot, side) {
  rot = rot %% 180
  # if(! rot %in% c(0, 90, 270)) {
  #     stop_wrap("Only support horizontal or vertical rotations for text.\n")
  # }
  if(side == "left") {
    if(rot == 0) {
      return(c(1, 0.5))
    } else if(rot == 90) {
      return(c(0.5, 0))
    } else if(rot == 270) {
      return(c(0.5, 1))
    }
  } else if(side == "right") {
    if(rot >= 0 && rot < 90) {
      return(c(0, 0.5))
    } else if(rot == 90) {
      return(c(0.5, 1))
    } else if(rot > 90 && rot < 180) {
      return(c(0, 0.5))
    }
  } else if(side == "top") {
    if(rot == 0) {
      return(c(0.5, 0))
    } else if(rot > 0 && rot <= 90) {
      return(c(0, 0.5))
    } else if(rot > 90 && rot <= 180) {
      return(c(1, 0.5))
    }
  } else if(side == "bottom") {
    if(rot == 0) {
      return(c(0.5, 1))
    } else if(rot > 0 && rot <= 90) {
      return(c(1, 0.5))
    } else if(rot > 90 && rot <= 180) {
      return(c(0, 0.5))
    }
  }
}

dev.null = function(...) {
  pdf(file = NULL, ...)
}

dev.off2 = function () {
  i1 = dev.prev()
  i2 = dev.cur()
  
  if (i1 == 2) {
    dev.set(i1)
  } else if(i1 > 2) {
    i11 = dev.prev(i1)
    if(names(i11) == "RStudioGD") {
      dev.set(i11)
    } else {
      dev.set(i1)
    }
  }
  dev.off(i2)
}

# == title
# Constructor method for Heatmap class
#
# == param
# -matrix A matrix. Either numeric or character. If it is a simple vector, it will be
#         converted to a one-column matrix.
# -col A vector of colors if the color mapping is discrete or a color mapping 
#      function if the matrix is continuous numbers (should be generated by `circlize::colorRamp2`). If the matrix is continuous,
#      the value can also be a vector of colors so that colors can be interpolated. Pass to `ColorMapping`. For more details
#      and examples, please refer to https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#colors .
# -name Name of the heatmap. By default the heatmap name is used as the title of the heatmap legend.
# -na_col Color for ``NA`` values.
# -rect_gp Graphic parameters for drawing rectangles (for heatmap body). The value should be specified by `grid::gpar` and ``fill`` parameter is ignored.
# -color_space The color space in which colors are interpolated. Only used if ``matrix`` is numeric and 
#            ``col`` is a vector of colors. Pass to `circlize::colorRamp2`.
# -border Whether draw border. The value can be logical or a string of color.
# -border_gp Graphic parameters for the borders. If you want to set different parameters for different heatmap slices,
#           please consider to use `decorate_heatmap_body`.
# -cell_fun Self-defined function to add graphics on each cell. Seven parameters will be passed into 
#           this function: ``j``, ``i``, ``x``, ``y``, ``width``, ``height``, ``fill`` which are column index,
#           row index in ``matrix``, coordinate of the cell,
#           the width and height of the cell and the filled color. ``x``, ``y``, ``width`` and ``height`` are all `grid::unit` objects.
# -layer_fun Similar as ``cell_fun``, but is vectorized. Check https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#customize-the-heatmap-body .
# -jitter Random shifts added to the matrix. The value can be logical or a single numeric value. It it is ``TRUE``, random 
#      values from uniform distribution between 0 and 1e-10 are generated. If it is a numeric value,
#      the range for the uniform distribution is (0, ``jitter``). It is mainly to solve the problem of "Error: node stack overflow"
#      when there are too many identical rows/columns for plotting the dendrograms. ADD: From version 2.5.6, the error of node stack overflow
#      has been fixed, now this argument is ignored.
# -row_title Title on the row.
# -row_title_side Will the title be put on the left or right of the heatmap?
# -row_title_gp Graphic parameters for row title.
# -row_title_rot Rotation of row title.
# -column_title Title on the column.
# -column_title_side Will the title be put on the top or bottom of the heatmap?
# -column_title_gp Graphic parameters for column title.
# -column_title_rot Rotation of column titles.
# -cluster_rows If the value is a logical, it controls whether to make cluster on rows. The value can also
#               be a `stats::hclust` or a `stats::dendrogram` which already contains clustering.
#               Check https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#clustering .
# -cluster_row_slices If rows are split into slices, whether perform clustering on the slice means?
# -clustering_distance_rows It can be a pre-defined character which is in 
#                ("euclidean", "maximum", "manhattan", "canberra", "binary", 
#                "minkowski", "pearson", "spearman", "kendall"). It can also be a function.
#                If the function has one argument, the input argument should be a matrix and 
#                the returned value should be a `stats::dist` object. If the function has two arguments,
#                the input arguments are two vectors and the function calculates distance between these
#                two vectors.
# -clustering_method_rows Method to perform hierarchical clustering, pass to `stats::hclust`.
# -row_dend_side Should the row dendrogram be put on the left or right of the heatmap?
# -row_dend_width Width of the row dendrogram, should be a `grid::unit` object.
# -show_row_dend Whether show row dendrogram?
# -row_dend_gp Graphic parameters for the dendrogram segments. If users already provide a `stats::dendrogram`
#                object with edges rendered, this argument will be ignored.
# -row_dend_reorder Apply reordering on row dendrograms. The value can be a logical value or a vector which contains weight 
#               which is used to reorder rows. The reordering is applied by `stats::reorder.dendrogram`.
# -cluster_columns Whether make cluster on columns? Same settings as ``cluster_rows``.
# -cluster_column_slices If columns are split into slices, whether perform clustering on the slice means?
# -clustering_distance_columns Same setting as ``clustering_distance_rows``.
# -clustering_method_columns Method to perform hierarchical clustering, pass to `stats::hclust`.
# -column_dend_side Should the column dendrogram be put on the top or bottom of the heatmap?
# -column_dend_height height of the column cluster, should be a `grid::unit` object.
# -show_column_dend Whether show column dendrogram?
# -column_dend_gp Graphic parameters for dendrogram segments. Same settings as ``row_dend_gp``.
# -column_dend_reorder Apply reordering on column dendrograms. Same settings as ``row_dend_reorder``.
# -row_order Order of rows. Manually setting row order turns off clustering.
# -column_order Order of column.
# -row_labels Optional row labels which are put as row names in the heatmap.
# -row_names_side Should the row names be put on the left or right of the heatmap?
# -show_row_names Whether show row names.
# -row_names_max_width Maximum width of row names viewport.
# -row_names_gp Graphic parameters for row names.
# -row_names_rot Rotation of row names.
# -row_names_centered Should row names put centered?
# -column_labels Optional column labels which are put as column names in the heatmap.
# -column_names_side Should the column names be put on the top or bottom of the heatmap?
# -column_names_max_height Maximum height of column names viewport.
# -show_column_names Whether show column names.
# -column_names_gp Graphic parameters for drawing text.
# -column_names_rot Rotation of column names.
# -column_names_centered Should column names put centered?
# -top_annotation A `HeatmapAnnotation` object.
# -bottom_annotation A `HeatmapAnnotation` object.
# -left_annotation It should be specified by `rowAnnotation`.
# -right_annotation it should be specified by `rowAnnotation`.
# -km Apply k-means clustering on rows. If the value is larger than 1, the heatmap will be split by rows according to the k-means clustering.
#     For each row slice, hierarchical clustering is still applied with parameters above.
# -split A vector or a data frame by which the rows are split. But if ``cluster_rows`` is a clustering object, ``split`` can be a single number
#        indicating to split the dendrogram by `stats::cutree`.
# -row_km Same as ``km``.
# -row_km_repeats Number of k-means runs to get a consensus k-means clustering. Note if ``row_km_repeats`` is set to more than one, the final number
#                of groups might be smaller than ``row_km``, but this might means the original ``row_km`` is not a good choice.
# -row_split Same as ``split``.
# -column_km K-means clustering on columns.
# -column_km_repeats Number of k-means runs to get a consensus k-means clustering. Similar as ``row_km_repeats``.
# -column_split Split on columns. For heatmap splitting, please refer to https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#heatmap-split .
# -gap Gap between row slices if the heatmap is split by rows. The value should be a `grid::unit` object.
# -row_gap Same as ``gap``.
# -column_gap Gap between column slices.
# -show_parent_dend_line When heatmap is split, whether to add a dashed line to mark parent dendrogram and children dendrograms?
# -width Width of the heatmap body.
# -height Height of the heatmap body.
# -heatmap_width Width of the whole heatmap (including heatmap components)
# -heatmap_height Height of the whole heatmap (including heatmap components). Check https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#size-of-the-heatmap .
# -show_heatmap_legend Whether show heatmap legend?
# -heatmap_legend_param A list contains parameters for the heatmap legends. See `color_mapping_legend,ColorMapping-method` for all available parameters.
# -use_raster Whether render the heatmap body as a raster image. It helps to reduce file size when the matrix is huge. If number of rows or columns is more than 2000, it is by default turned on. Note if ``cell_fun``
#       is set, ``use_raster`` is enforced to be ``FALSE``.
# -raster_device Graphic device which is used to generate the raster image.
# -raster_quality A value larger than 1.
# -raster_device_param A list of further parameters for the selected graphic device. For raster image support, please check https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#heatmap-as-raster-image .
# -raster_resize_mat Whether resize the matrix to let the dimension of the matrix the same as the dimension of the raster image?
#          The value can be logical. If it is ``TRUE``, `base::mean` is used to summarize the sub matrix which corresponds to a single pixel.
#          The value can also be a summary function, e.g. `base::max`.
# -raster_by_magick Whether to use `magick::image_resize` to scale the image.
# -raster_magick_filter Pass to ``filter`` argument of `magick::image_resize`. A character scalar and all possible values
#          are in `magick::filter_types`. The default is ``"Lanczos"``.
# -post_fun A function which will be executed after the heatmap list is drawn.
#
# == details
# The initialization function only applies parameter checking and fill values to the slots with some validation.
# 
# Following methods can be applied to the `Heatmap-class` object:
#
# - `show,Heatmap-method`: draw a single heatmap with default parameters
# - `draw,Heatmap-method`: draw a single heatmap.
# - ``+`` or `\%v\%` append heatmaps and annotations to a list of heatmaps.
#
# The constructor function pretends to be a high-level graphic function because the ``show`` method
# of the `Heatmap-class` object actually plots the graphics.
#
# == seealso
# https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html
#
# == value
# A `Heatmap-class` object.
#
# == author
# Zuguang Gu <z.gu@dkfz.de>
#
Heatmap_mod = function(matrix, col, name, 
                   na_col = "grey", 
                   color_space = "LAB",
                   rect_gp = gpar(col = NA), 
                   border = NA,
                   border_gp = gpar(col = "black"),
                   cell_fun = NULL,
                   layer_fun = NULL,
                   jitter = FALSE,
                   
                   row_title = character(0), 
                   row_title_side = c("left", "right"), 
                   row_title_gp = gpar(fontsize = 13.2), 
                   row_title_rot = switch(row_title_side[1], "left" = 90, "right" = 270),
                   column_title = character(0), 
                   column_title_side = c("top", "bottom"), 
                   column_title_gp = gpar(fontsize = 13.2), 
                   column_title_rot = 0,
                   
                   cluster_rows = TRUE, 
                   cluster_row_slices = TRUE,
                   clustering_distance_rows = "euclidean",
                   clustering_method_rows = "complete", 
                   row_dend_side = c("left", "right"),
                   row_dend_width = unit(10, "mm"), 
                   show_row_dend = TRUE, 
                   row_dend_reorder = is.logical(cluster_rows) || is.function(cluster_rows),
                   row_dend_gp = gpar(), 
                   cluster_columns = TRUE, 
                   cluster_column_slices = TRUE,
                   clustering_distance_columns = "euclidean", 
                   clustering_method_columns = "complete",
                   column_dend_side = c("top", "bottom"), 
                   column_dend_height = unit(10, "mm"), 
                   show_column_dend = TRUE, 
                   column_dend_gp = gpar(), 
                   column_dend_reorder = is.logical(cluster_columns) || is.function(cluster_columns),
                   
                   row_order = NULL, 
                   column_order = NULL,
                   
                   row_labels = rownames(matrix),
                   row_names_side = c("right", "left"), 
                   show_row_names = TRUE, 
                   row_names_max_width = unit(6, "cm"), 
                   row_names_gp = gpar(fontsize = 12), 
                   row_names_rot = 0,
                   row_names_centered = FALSE,
                   column_labels = colnames(matrix),
                   column_names_side = c("bottom", "top"), 
                   show_column_names = TRUE, 
                   column_names_max_height = unit(6, "cm"), 
                   column_names_gp = gpar(fontsize = 12),
                   column_names_rot = 90,
                   column_names_centered = FALSE,
                   
                   top_annotation = NULL,
                   bottom_annotation = NULL,
                   left_annotation = NULL,
                   right_annotation = NULL,
                   
                   km = 1, 
                   split = NULL, 
                   row_km = km,
                   row_km_repeats = 1,
                   row_split = split,
                   column_km = 1,
                   column_km_repeats = 1,
                   column_split = NULL,
                   gap = unit(1, "mm"),
                   row_gap = unit(1, "mm"),
                   column_gap = unit(1, "mm"),
                   show_parent_dend_line = ht_opt$show_parent_dend_line,
                   
                   heatmap_width = unit(1, "npc"),
                   width = NULL,
                   heatmap_height = unit(1, "npc"), 
                   height = NULL,
                   
                   show_heatmap_legend = TRUE,
                   heatmap_legend_param = list(title = name),
                   
                   use_raster = NULL, 
                   raster_device = c("png", "jpeg", "tiff", "CairoPNG", "CairoJPEG", "CairoTIFF", "agg_png"),
                   raster_quality = 1,
                   raster_device_param = list(),
                   raster_resize_mat = FALSE,
                   raster_by_magick = requireNamespace("magick", quietly = TRUE),
                   raster_magick_filter = NULL,
                   
                   post_fun = NULL) {
  
  dev.null()
  on.exit(dev.off2())
  
  verbose = ht_opt("verbose")
  
  .Object = new("Heatmap")
  if(missing(name)) {
    name = paste0("matrix_", get_heatmap_index() + 1)
    increase_heatmap_index()
  } else if(is.null(name)) {
    name = paste0("matrix_", get_heatmap_index() + 1)
    increase_heatmap_index()
  }
  if(name == "") {
    stop_wrap("Heatmap name cannot be empty string.")
  }
  .Object@name = name
  
  # re-define some of the argument values according to global settings
  called_args = names(as.list(match.call())[-1])
  for(opt_name in c("row_names_gp", "column_names_gp", "row_title_gp", "column_title_gp")) {
    opt_name2 = paste0("heatmap_", opt_name)
    if(! opt_name %in% called_args) { # if this argument is not called
      if(!is.null(ht_opt(opt_name2))) {
        if(verbose) qqcat("re-assign @{opt_name} with `ht_opt('@{opt_name2}'')`\n")
        assign(opt_name, ht_opt(opt_name2))
      }
    }
  }
  
  if("top_annotation_height" %in% called_args) {
    stop_wrap("`top_annotation_height` is removed. Set the height directly in `HeatmapAnnotation()`.")
  }
  if("bottom_annotation_height" %in% called_args) {
    stop_wrap("`bottom_annotation_height` is removed. Set the height directly in `HeatmapAnnotation()`.")
  }
  if("combined_name_fun" %in% called_args) {
    stop_wrap("`combined_name_fun` is removed. Please directly set `row_names_title`. See https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html#titles-for-splitting")
  }
  
  if("heatmap_legend_param" %in% called_args) {
    for(opt_name in setdiff(c("title_gp", "title_position", "labels_gp", "grid_width", "grid_height", "border"), names(heatmap_legend_param))) {
      opt_name2 = paste0("legend_", opt_name)
      if(!is.null(ht_opt(opt_name2)))
        if(verbose) qqcat("re-assign heatmap_legend_param$@{opt_name} with `ht_opt('@{opt_name2}'')`\n")
      heatmap_legend_param[[opt_name]] = ht_opt(opt_name2)
    }
  } else {
    for(opt_name in c("title_gp", "title_position", "labels_gp", "grid_width", "grid_height", "border")) {
      opt_name2 = paste0("legend_", opt_name)
      if(!is.null(ht_opt(opt_name2)))
        if(verbose) qqcat("re-assign heatmap_legend_param$@{opt_name} with `ht_opt('@{opt_name2}'')`\n")
      heatmap_legend_param[[opt_name]] = ht_opt(opt_name2)
    }
  }
  
  if(is.data.frame(matrix)) {
    if(verbose) qqcat("convert data frame to matrix\n")
    warning_wrap("The input is a data frame-like object, convert it to a matrix.")
    if(!all(sapply(matrix, is.numeric))) {
      warning_wrap("Note: not all columns in the data frame are numeric. The data frame will be converted into a character matrix.")
    }
    matrix = as.matrix(matrix)
  }
  fa_level = NULL
  if(!is.matrix(matrix)) {
    if(is.atomic(matrix)) {
      if(is.factor(matrix)) {
        fa_level = levels(matrix)
      }
      rn = names(matrix)
      matrix = matrix(matrix, ncol = 1)
      if(!is.null(rn)) rownames(matrix) = rn
      if(!missing(name)) colnames(matrix) = name
      if(verbose) qqcat("convert simple vector to one-column matrix\n")
    } else {
      stop_wrap("If input is not a matrix, it should be a simple vector.")
    }
  }
  
  # if(ncol(matrix) == 0 || nrow(matrix) == 0) {
  #     show_heatmap_legend = FALSE
  #     .Object@heatmap_param$show_heatmap_legend = FALSE
  # }
  
  # if(ncol(matrix) == 0 && (!is.null(left_annotation) || !is.null(right_annotation))) {
  #     message_wrap("If you have row annotations for a zeor-column matrix, please directly use in form of `rowAnnotation(...) + NULL`")
  #     return(invisible(NULL))
  # }
  # if(nrow(matrix) == 0 && (!is.null(top_annotation) || !is.null(bottom_annotation))) {
  #     message_wrap("If you have column annotations for a zero-row matrix, please directly use in form of `HeatmapAnnotation(...) %v% NULL`")
  #     return(invisible(NULL))
  # }
  
  ### normalize km/split and row_km/row_split
  if(missing(row_km)) row_km = km
  if(is.null(row_km)) row_km = 1
  if(missing(row_split)) row_split = split
  if(missing(row_gap)) row_gap = gap
  if(is.null(column_km)) column_km = 1
  
  ####### zero and one column matrix ########
  if(ncol(matrix) == 0 || nrow(matrix) == 0) {
    if(!inherits(cluster_columns, c("dendrogram", "hclust"))) {
      cluster_columns = FALSE
      show_column_dend = FALSE
    }
    if(!inherits(cluster_rows, c("dendrogram", "hclust"))) {
      cluster_rows = FALSE
      show_row_dend = FALSE
    }
    row_km = 1
    column_km = 1
    if(verbose) qqcat("zero row/column matrix, set cluster_columns/rows to FALSE\n")
  }
  if(ncol(matrix) == 1) {
    if(!inherits(cluster_columns, c("dendrogram", "hclust"))) {
      cluster_columns = FALSE
      show_column_dend = FALSE
    }
    column_km = 1
    if(verbose) qqcat("one-column matrix, set cluster_columns to FALSE\n")
  }
  if(nrow(matrix) == 1) {
    if(!inherits(cluster_rows, c("dendrogram", "hclust"))) {
      cluster_rows = FALSE
      show_row_dend = FALSE
    }
    row_km = 1
    if(verbose) qqcat("one-row matrix, set cluster_rows to FALSE\n")
  }
  
  if(is.character(matrix)) {
    called_args = names(match.call()[-1])
    if("clustering_distance_rows" %in% called_args) {
    } else if(inherits(cluster_rows, c("dendrogram", "hclust"))) {
    } else {
      cluster_rows = FALSE
      show_row_dend = FALSE
    }
    row_dend_reorder = FALSE
    cluster_row_slices = FALSE
    
    if(inherits(cluster_rows, c("dendrogram", "hclust")) && length(row_split) == 1) {
      if(!"cluster_row_slices" %in% called_args) {
        cluster_row_slices = TRUE
      }
    }
    
    if("clustering_distance_columns" %in% called_args) {
    } else if(inherits(cluster_columns, c("dendrogram", "hclust"))) {
    } else {
      cluster_columns = FALSE
      show_column_dend = FALSE
    }
    column_dend_reorder = FALSE
    cluster_column_slices = FALSE
    
    if(inherits(cluster_columns, c("dendrogram", "hclust")) && length(column_split) == 1) {
      if(!"cluster_column_slices" %in% called_args) {
        cluster_column_slices = TRUE
      }
    }
    
    row_km = 1
    column_km = 1
    if(verbose) qqcat("matrix is character. Do not cluster unless distance method is provided.\n")
  }
  class(matrix) = "matrix"
  .Object@matrix = matrix
  
  .Object@matrix_param$row_km = row_km
  .Object@matrix_param$row_km_repeats = row_km_repeats
  .Object@matrix_param$row_gap = row_gap
  .Object@matrix_param$column_km = column_km
  .Object@matrix_param$column_km_repeats = column_km_repeats
  .Object@matrix_param$column_gap = column_gap
  .Object@matrix_param$jitter = jitter
  
  ### check row_split and column_split ###
  if(!is.null(row_split)) {
    if(inherits(cluster_rows, c("dendrogram", "hclust"))) {
      if(is.numeric(row_split) && length(row_split) == 1) {
        .Object@matrix_param$row_split = row_split
      } else {
        stop_wrap("When `cluster_rows` is a dendrogram, `row_split` can only be a single number.")
      }
    } else {
      if(identical(cluster_rows, TRUE) && is.numeric(row_split) && length(row_split) == 1) {
        
      } else {
        if(!is.data.frame(row_split)) row_split = data.frame(row_split)
        if(nrow(row_split) != nrow(matrix)) {
          stop_wrap("Length or nrow of `row_split` should be same as nrow of `matrix`.")
        }
      }
    }
  }
  .Object@matrix_param$row_split = row_split
  
  if(!is.null(column_split)) {
    if(inherits(cluster_columns, c("dendrogram", "hclust"))) {
      if(is.numeric(column_split) && length(column_split) == 1) {
        .Object@matrix_param$column_split = column_split
      } else {
        stop_wrap("When `cluster_columns` is a dendrogram, `column_split` can only be a single number.")
      }
    } else {
      if(identical(cluster_columns, TRUE) && is.numeric(column_split) && length(column_split) == 1) {
        
      } else {
        if(!is.data.frame(column_split)) column_split = data.frame(column_split)
        if(nrow(column_split) != ncol(matrix)) {
          stop_wrap("Length or ncol of `column_split` should be same as ncol of `matrix`.")
        }
      }
    }
  }
  .Object@matrix_param$column_split = column_split
  
  
  ### parameters for heatmap body ###
  .Object@matrix_param$gp = check_gp(rect_gp)
  if(missing(border)) {
    if(!is.null(ht_opt$heatmap_border)) border = ht_opt$heatmap_border
  }
  if(!missing(border_gp) && missing(border)) border = TRUE
  .Object@matrix_param$border = border
  .Object@matrix_param$border_gp = border_gp
  
  if(!is.null(cell_fun)) {
    global_vars = codetools::findGlobals(cell_fun, merge = FALSE)$variables
    
    ee = new.env(parent = environment(cell_fun))
    for(v in global_vars) {
      assign(v, value = get(v, envir = environment(cell_fun)), envir = ee)
    }
    environment(cell_fun) = ee
  }
  if(!is.null(layer_fun)) {
    global_vars = codetools::findGlobals(layer_fun, merge = FALSE)$variables
    
    ee = new.env(parent = environment(layer_fun))
    for(v in global_vars) {
      assign(v, value = get(v, envir = environment(layer_fun)), envir = ee)
    }
    environment(layer_fun) = ee
  }
  
  .Object@matrix_param$cell_fun = cell_fun
  .Object@matrix_param$layer_fun = layer_fun
  
  if(nrow(matrix) > 100 || ncol(matrix) > 100) {
    if(!is.null(cell_fun)) {
      warning_wrap("You defined `cell_fun` for a heatmap with more than 100 rows or columns, which might be very slow to draw. Consider to use the vectorized version `layer_fun`.")
    }
  }
  
  ### color for main matrix #########
  if(ncol(matrix) > 0 && nrow(matrix) > 0) {
    if(missing(col)) {
      col = default_col(matrix, main_matrix = TRUE)
      if(!is.null(fa_level)) {
        col = col[fa_level]
      }
      if(verbose) qqcat("color is not specified, use randomly generated colors\n")
    }
    if(is.null(col)) {
      col = default_col(matrix, main_matrix = TRUE)
      if(!is.null(fa_level)) {
        col = col[fa_level]
      }
      if(verbose) qqcat("color is not specified, use randomly generated colors\n")
    }
    if(is.function(col)) {
      if(is.null(attr(col, "breaks"))) {
        breaks = seq(min(matrix, na.rm = TRUE), max(matrix, na.rm = TRUE), length.out = 5)
        rg = range(breaks)
        diff = rg[2] - rg[1]
        rg[1] = rg[1] + diff*0.05
        rg[2] = rg[2] - diff*0.05
        
        le = pretty(rg, n = 3)
        .Object@matrix_color_mapping = ColorMapping(col_fun = col, name = name, breaks = le, na_col = na_col)
      } else {
        .Object@matrix_color_mapping = ColorMapping(col_fun = col, name = name, na_col = na_col)
      }
      if(verbose) qqcat("input color is a color mapping function\n")
    } else if(inherits(col, "ColorMapping")){
      .Object@matrix_color_mapping = col
      if(verbose) qqcat("input color is a ColorMapping object\n")
    } else {
      
      if(is.null(names(col))) {
        if(length(col) == length(unique(as.vector(matrix)))) {
          if(is.null(fa_level)) {
            if(is.numeric(matrix)) {
              names(col) = sort(unique(as.vector(matrix)))
              col = rev(col)
            } else {
              names(col) = sort(unique(as.vector(matrix)))
            }
          } else {
            names(col) = fa_level
          }
          .Object@matrix_color_mapping = ColorMapping(colors = col, name = name, na_col = na_col)
          if(verbose) qqcat("input color is a vector with no names, treat it as discrete color mapping\n")
        } else if(is.numeric(matrix)) {
          #col = circlize::colorRamp2(seq(min(matrix, na.rm = TRUE), round(max_prob, str_count(as.character(max_prob), '0')), length.out = length(col)),
          col = colorRamp2(seq(min(matrix, na.rm = TRUE), max(matrix, na.rm = TRUE), length.out = length(col)),
                           col, space = color_space)
          .Object@matrix_color_mapping = ColorMapping(col_fun = col, name = name, na_col = na_col)
          if(verbose) qqcat("input color is a vector with no names, treat it as continuous color mapping\n")
        } else {
          stop_wrap("`col` should have names to map to values in `mat`.")
        }
      } else {
        full_col = col
        # note here col can be reduced
        if(is.null(fa_level)) {
          col = col[intersect(c(names(col), "_NA_"), as.character(matrix))]
        } else {
          col = col[intersect(c(fa_level, "_NA_"), names(col))]
        }
        if(!is.null(heatmap_legend_param) && !identical(.Object@matrix_param$gp$type, "none")) {
          if(!is.null(heatmap_legend_param$at) && !is.null(heatmap_legend_param[["labels"]])) {
            l = heatmap_legend_param$at %in% names(col)
            heatmap_legend_param$at = heatmap_legend_param$at[l]
            heatmap_legend_param[["labels"]] = heatmap_legend_param[["labels"]][l]
          } else if(is.null(heatmap_legend_param$at) && !is.null(heatmap_legend_param$labels)) {
            l = heatmap_legend_param[["labels"]] %in% names(col)
            heatmap_legend_param[["labels"]] = heatmap_legend_param[["labels"]][l]
          } else if(!is.null(heatmap_legend_param$at) && is.null(heatmap_legend_param[["labels"]])) {
            l = heatmap_legend_param$at %in% names(col)
            heatmap_legend_param$at = heatmap_legend_param$at[l]
          }
        }
        .Object@matrix_color_mapping = ColorMapping(colors = col, name = name, na_col = na_col, full_col = full_col)
        if(verbose) qqcat("input color is a named vector\n")
      }
    }
    .Object@matrix_legend_param = heatmap_legend_param
  }
  
  ##### titles, should also consider titles after row splitting #####
  if(identical(row_title, NA) || identical(row_title, "")) {
    row_title = character(0)
  }
  .Object@row_title = row_title
  .Object@row_title_param$rot = row_title_rot %% 360
  .Object@row_title_param$side = match.arg(row_title_side)[1]
  .Object@row_title_param$gp = check_gp(row_title_gp)  # if the number of settings is same as number of row-splits, gp will be adjusted by `make_row_dend`
  .Object@row_title_param$just = get_text_just(rot = row_title_rot, side = .Object@row_title_param$side)
  
  if(identical(column_title, NA) || identical(column_title, "")) {
    column_title = character(0)
  }
  .Object@column_title = column_title
  .Object@column_title_param$rot = column_title_rot %% 360
  .Object@column_title_param$side = match.arg(column_title_side)[1]
  .Object@column_title_param$gp = check_gp(column_title_gp)
  .Object@column_title_param$just = get_text_just(rot = column_title_rot, side = .Object@column_title_param$side)
  
  ### row labels/column labels ###
  if(is.null(rownames(matrix))) {
    if(is.null(row_labels)) {
      show_row_names = FALSE
    }
  }
  .Object@row_names_param$labels = row_labels
  .Object@row_names_param$side = match.arg(row_names_side)[1]
  .Object@row_names_param$show = show_row_names
  .Object@row_names_param$gp = check_gp(row_names_gp)
  .Object@row_names_param$rot = row_names_rot
  .Object@row_names_param$centered = row_names_centered
  .Object@row_names_param$max_width = row_names_max_width + unit(2, "mm")
  # we use anno_text to draw row/column names because it already takes care of text rotation
  if(show_row_names) {
    if(length(row_labels) != nrow(matrix)) {
      stop_wrap("Length of `row_labels` should be the same as the nrow of matrix.")
    }
    if(row_names_centered) {
      row_names_anno = anno_text(row_labels, which = "row", gp = row_names_gp, rot = row_names_rot,
                                 location = 0.5, 
                                 just = "center")
    } else {
      row_names_anno = anno_text(row_labels, which = "row", gp = row_names_gp, rot = row_names_rot,
                                 location = ifelse(.Object@row_names_param$side == "left", 1, 0), 
                                 just = ifelse(.Object@row_names_param$side == "left", "right", "left"))
    }
    .Object@row_names_param$anno = row_names_anno
  }
  
  if(is.null(colnames(matrix))) {
    if(is.null(column_labels)) {
      show_column_names = FALSE
    }
  }
  .Object@column_names_param$labels = column_labels
  .Object@column_names_param$side = match.arg(column_names_side)[1]
  .Object@column_names_param$show = show_column_names
  .Object@column_names_param$gp = check_gp(column_names_gp)
  .Object@column_names_param$rot = column_names_rot
  .Object@column_names_param$centered = column_names_centered
  .Object@column_names_param$max_height = column_names_max_height + unit(2, "mm")
  if(show_column_names) {
    if(length(column_labels) != ncol(matrix)) {
      stop_wrap("Length of `column_labels` should be the same as the ncol of matrix.")
    }
    if(column_names_centered) {
      column_names_anno = anno_text(column_labels, which = "column", gp = column_names_gp, rot = column_names_rot,
                                    location = 0.5, 
                                    just = "center")
    } else {
      column_names_anno = anno_text(column_labels, which = "column", gp = column_names_gp, rot = column_names_rot,
                                    location = ifelse(.Object@column_names_param$side == "top", 0, 1), 
                                    just = ifelse(.Object@column_names_param$side == "top", 
                                                  ifelse(.Object@column_names_param$rot >= 0, "left", "right"),
                                                  ifelse(.Object@column_names_param$rot >= 0, "right", "left")
                                    ))
    }
    .Object@column_names_param$anno = column_names_anno
  }
  
  #### dendrograms ########
  if(missing(cluster_rows) && !missing(row_order)) {
    cluster_rows = FALSE
  }
  if(is.logical(cluster_rows)) {
    if(!cluster_rows) {
      row_dend_width = unit(0, "mm")
      show_row_dend = FALSE
    }
    .Object@row_dend_param$cluster = cluster_rows
  } else if(inherits(cluster_rows, "dendrogram") || inherits(cluster_rows, "hclust")) {
    .Object@row_dend_param$obj = cluster_rows
    .Object@row_dend_param$cluster = TRUE
  } else if(inherits(cluster_rows, "function")) {
    .Object@row_dend_param$fun = cluster_rows
    .Object@row_dend_param$cluster = TRUE
  } else {
    oe = try(cluster_rows <- as.dendrogram(cluster_rows), silent = TRUE)
    if(!inherits(oe, "try-error")) {
      .Object@row_dend_param$obj = cluster_rows
      .Object@row_dend_param$cluster = TRUE
    } else {
      stop_wrap("`cluster_rows` should be a logical value, a clustering function or a clustering object.")
    }
  }
  if(!show_row_dend) {
    row_dend_width = unit(0, "mm")
  }
  .Object@row_dend_list = list()
  .Object@row_dend_param$distance = clustering_distance_rows
  .Object@row_dend_param$method = clustering_method_rows
  .Object@row_dend_param$side = match.arg(row_dend_side)[1]
  .Object@row_dend_param$width = row_dend_width + ht_opt$DENDROGRAM_PADDING  # append the gap
  .Object@row_dend_param$show = show_row_dend
  .Object@row_dend_param$gp = check_gp(row_dend_gp)
  .Object@row_dend_param$reorder = row_dend_reorder
  .Object@row_order_list = list() # default order
  if(is.null(row_order)) {
    .Object@row_order = seq_len(nrow(matrix))
  }  else {
    if(is.character(row_order)) {
      row_order = structure(seq_len(nrow(matrix)), names = rownames(matrix))[row_order]
    }
    if(any(is.na(row_order))) {
      stop_wrap("`row_order` should not contain NA values.")
    }
    if(length(row_order) != nrow(matrix)) {
      stop_wrap("length of `row_order` should be same as the number of marix rows.")
    }
    .Object@row_order = row_order
  }
  .Object@row_dend_param$cluster_slices = cluster_row_slices
  
  if(missing(cluster_columns) && !missing(column_order)) {
    cluster_columns = FALSE
  }
  if(is.logical(cluster_columns)) {
    if(!cluster_columns) {
      column_dend_height = unit(0, "mm")
      show_column_dend = FALSE
    }
    .Object@column_dend_param$cluster = cluster_columns
  } else if(inherits(cluster_columns, "dendrogram") || inherits(cluster_columns, "hclust")) {
    .Object@column_dend_param$obj = cluster_columns
    .Object@column_dend_param$cluster = TRUE
  } else if(inherits(cluster_columns, "function")) {
    .Object@column_dend_param$fun = cluster_columns
    .Object@column_dend_param$cluster = TRUE
  } else {
    oe = try(cluster_columns <- as.dendrogram(cluster_columns), silent = TRUE)
    if(!inherits(oe, "try-error")) {
      .Object@column_dend_param$obj = cluster_columns
      .Object@column_dend_param$cluster = TRUE
    } else {
      stop_wrap("`cluster_columns` should be a logical value, a clustering function or a clustering object.")
    }
  }
  if(!show_column_dend) {
    column_dend_height = unit(0, "mm")
  }
  .Object@column_dend_list = list()
  .Object@column_dend_param$distance = clustering_distance_columns
  .Object@column_dend_param$method = clustering_method_columns
  .Object@column_dend_param$side = match.arg(column_dend_side)[1]
  .Object@column_dend_param$height = column_dend_height + ht_opt$DENDROGRAM_PADDING  # append the gap
  .Object@column_dend_param$show = show_column_dend
  .Object@column_dend_param$gp = check_gp(column_dend_gp)
  .Object@column_dend_param$reorder = column_dend_reorder
  if(is.null(column_order)) {
    .Object@column_order = seq_len(ncol(matrix))
  } else {
    if(is.character(column_order)) {
      column_order = structure(seq_len(ncol(matrix)), names = colnames(matrix))[column_order]
    }
    if(any(is.na(column_order))) {
      stop_wrap("`column_order` should not contain NA values.")
    }
    if(length(column_order) != ncol(matrix)) {
      stop_wrap("length of `column_order` should be same as the number of marix columns")
    }
    .Object@column_order = column_order
  }
  .Object@column_dend_param$cluster_slices = cluster_column_slices
  
  ######### annotations #############
  .Object@top_annotation = top_annotation # a `HeatmapAnnotation` object
  if(is.null(top_annotation)) {
    .Object@top_annotation_param$height = unit(0, "mm")    
  } else {
    if(inherits(top_annotation, "AnnotationFunction")) {
      stop_wrap("The annotation function `anno_*()` should be put inside `HeatmapAnnotation()`.")
    }
    .Object@top_annotation_param$height = height(top_annotation) + ht_opt$COLUMN_ANNO_PADDING  # append the gap
  }
  if(!is.null(top_annotation)) {
    if(length(top_annotation) > 0) {
      if(!.Object@top_annotation@which == "column") {
        stop_wrap("`which` in `top_annotation` should only be `column`.")
      }
    }
    nb = nobs(top_annotation)
    if(!is.na(nb)) {
      if(nb != ncol(.Object@matrix)) {
        stop_wrap("number of observations in top annotation should be as same as ncol of the matrix.")
      }
    }
  }
  if(!is.null(top_annotation)) {
    validate_anno_names_with_matrix(matrix, top_annotation, "column")
  }
  
  .Object@bottom_annotation = bottom_annotation # a `HeatmapAnnotation` object
  if(is.null(bottom_annotation)) {
    .Object@bottom_annotation_param$height = unit(0, "mm")
  } else {
    if(inherits(bottom_annotation, "AnnotationFunction")) {
      stop_wrap("The annotation function `anno_*()` should be put inside `HeatmapAnnotation()`.")
    }
    .Object@bottom_annotation_param$height = height(bottom_annotation) + ht_opt$COLUMN_ANNO_PADDING  # append the gap
  }
  if(!is.null(bottom_annotation)) {
    if(length(bottom_annotation) > 0) {
      if(!.Object@bottom_annotation@which == "column") {
        stop_wrap("`which` in `bottom_annotation` should only be `column`.")
      }
    }
    nb = nobs(bottom_annotation)
    if(!is.na(nb)) {
      if(nb != ncol(.Object@matrix)) {
        stop_wrap("number of observations in bottom annotation should be as same as ncol of the matrix.")
      }
    }
  }
  if(!is.null(bottom_annotation)) {
    validate_anno_names_with_matrix(matrix, bottom_annotation, "column")
  }
  
  .Object@left_annotation = left_annotation # a `rowAnnotation` object
  if(is.null(left_annotation)) {
    .Object@left_annotation_param$width = unit(0, "mm")
  } else {
    if(inherits(left_annotation, "AnnotationFunction")) {
      stop_wrap("The annotation function `anno_*()` should be put inside `rowAnnotation()`.")
    }
    .Object@left_annotation_param$width = width(left_annotation) + ht_opt$ROW_ANNO_PADDING  # append the gap
  }
  if(!is.null(left_annotation)) {
    if(length(left_annotation) > 0) {
      if(!.Object@left_annotation@which == "row") {
        stop_wrap("`which` in `left_annotation` should only be `row`, or consider using `rowAnnotation()`.")
      }
    }
    nb = nobs(left_annotation)
    if(!is.na(nb)) {
      if(nb != nrow(.Object@matrix)) {
        stop_wrap("number of observations in left annotation should be same as nrow of the matrix.")
      }
    }
  }
  if(!is.null(left_annotation)) {
    validate_anno_names_with_matrix(matrix, left_annotation, "row")
  }
  
  .Object@right_annotation = right_annotation # a `rowAnnotation` object
  if(is.null(right_annotation)) {
    .Object@right_annotation_param$width = unit(0, "mm")
  } else {
    if(inherits(right_annotation, "AnnotationFunction")) {
      stop_wrap("The annotation function `anno_*()` should be put inside `rowAnnotation()`.")
    }
    .Object@right_annotation_param$width = width(right_annotation) + ht_opt$ROW_ANNO_PADDING  # append the gap
  }
  if(!is.null(right_annotation)) {
    if(length(right_annotation) > 0) {
      if(!.Object@right_annotation@which == "row") {
        stop_wrap("`which` in `right_annotation` should only be `row`, or consider using `rowAnnotation()`.")
      }
    }
    nb = nobs(right_annotation)
    if(!is.na(nb)) {
      if(nb != nrow(.Object@matrix)) {
        stop_wrap("number of observations in right annotation should be same as nrow of the matrix.")
      }
    }
  }
  if(!is.null(right_annotation)) {
    validate_anno_names_with_matrix(matrix, right_annotation, "row")
  }
  
  .Object@layout = list(
    layout_size = list(
      column_title_top_height = unit(0, "mm"),
      column_dend_top_height = unit(0, "mm"),
      column_anno_top_height = unit(0, "mm"),
      column_names_top_height = unit(0, "mm"),
      column_title_bottom_height = unit(0, "mm"),
      column_dend_bottom_height = unit(0, "mm"),
      column_anno_bottom_height = unit(0, "mm"),
      column_names_bottom_height = unit(0, "mm"),
      
      row_title_left_width = unit(0, "mm"),
      row_dend_left_width = unit(0, "mm"),
      row_names_left_width = unit(0, "mm"),
      row_dend_right_width = unit(0, "mm"),
      row_names_right_width = unit(0, "mm"),
      row_title_right_width = unit(0, "mm"),
      row_anno_left_width = unit(0, "mm"),
      row_anno_right_width = unit(0, "mm")
    ),
    
    layout_index = matrix(nrow = 0, ncol = 2),
    graphic_fun_list = list(),
    initialized = FALSE
  )
  
  if(is.null(width)) {
    width = unit(ncol(matrix), "null")
  } else if(is.numeric(width) && !inherits(width, "unit")) {
    width = unit(width, "null")
  } else if(!inherits(width, "unit")) {
    stop_wrap("`width` should be a `unit` object or a single number.")
  }
  
  if(is.null(height)) {
    height = unit(nrow(matrix), "null")
  } else if(is.numeric(height) && !inherits(height, "unit")) {
    height = unit(height, "null")
  } else if(!inherits(height, "unit")) {
    stop_wrap("`height` should be a `unit` object or a single number.")
  }
  
  if(!is.null(width) && !is.null(heatmap_width)) {
    if(is_abs_unit(width) && is_abs_unit(heatmap_width)) {
      stop_wrap("`heatmap_width` and `width` should not all be the absolute units.")
    }
  }
  if(!is.null(height) && !is.null(heatmap_height)) {
    if(is_abs_unit(height) && is_abs_unit(heatmap_height)) {
      stop_wrap("`heatmap_height` and `height` should not all be the absolute units.")
    }
  }
  
  if(is.null(use_raster)) {
    if(nrow(matrix) > 2000 && ncol(matrix) > 10) {
      use_raster = TRUE
      if(ht_opt$message) {
        message_wrap("`use_raster` is automatically set to TRUE for a matrix with more than 2000 rows. You can control `use_raster` argument by explicitly setting TRUE/FALSE to it.\n\nSet `ht_opt$message = FALSE` to turn off this message.")
      }
    } else if(ncol(matrix) > 2000 && nrow(matrix) > 10) {
      use_raster = TRUE
      if(ht_opt$message) {
        message_wrap("`use_raster` is automatically set to TRUE for a matrix with more than 2000 columns You can control `use_raster` argument by explicitly setting TRUE/FALSE to it.\n\nSet `ht_opt$message = FALSE` to turn off this message.")
      }
    } else {
      use_raster = FALSE
    }
  }
  
  if(use_raster) {
    if(missing(raster_by_magick)) {
      if(!raster_by_magick) {
        if(ht_opt$message) {
          message_wrap("'magick' package is suggested to install to give better rasterization.\n\nSet `ht_opt$message = FALSE` to turn off this message.")
        }
      }
    }
  }
  
  .Object@matrix_param$width = width
  .Object@matrix_param$height = height
  
  .Object@heatmap_param$width = heatmap_width
  .Object@heatmap_param$height = heatmap_height
  .Object@heatmap_param$show_heatmap_legend = show_heatmap_legend
  .Object@heatmap_param$use_raster = use_raster
  
  if(missing(raster_device)) {
    if(requireNamespace("Cairo", quietly = TRUE)) {
      raster_device = "CairoPNG"
    } else {
      raster_device = "png"
    }
  } else {
    raster_device = match.arg(raster_device)[1]
  }
  .Object@heatmap_param$raster_device = raster_device
  .Object@heatmap_param$raster_quality = raster_quality
  .Object@heatmap_param$raster_device_param = raster_device_param
  .Object@heatmap_param$raster_resize_mat = raster_resize_mat
  .Object@heatmap_param$raster_by_magick = raster_by_magick
  .Object@heatmap_param$raster_magick_filter = raster_magick_filter
  .Object@heatmap_param$verbose = verbose
  .Object@heatmap_param$post_fun = post_fun
  .Object@heatmap_param$calling_env = parent.frame()
  .Object@heatmap_param$show_parent_dend_line = show_parent_dend_line
  
  if(nrow(matrix) == 0) {
    .Object@matrix_param$height = unit(0, "mm")
  }
  if(ncol(matrix) == 0) {
    .Object@matrix_param$width = unit(0, "mm")
  }
  
  return(.Object)
  
}
